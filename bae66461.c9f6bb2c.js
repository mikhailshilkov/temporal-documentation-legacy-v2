(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{160:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return f}));var o=n(1),r=n(6),a=(n(0),n(183)),l={id:"java-workflow-interface",title:"Workflow Interface"},i={id:"java-workflow-interface",title:"Workflow Interface",description:"Workflow encapsulates the orchestration of activities and child workflows.",source:"@site/docs/java-workflow-interface.md",permalink:"/docs/java-workflow-interface",editUrl:"https://github.com/temporalio/temporal-documentation-legacy-v2/blob/master/docs/java-workflow-interface.md",sidebar:"docs",previous:{title:"Quick Start",permalink:"/docs/java-quick-start"},next:{title:"Implementing Workflows",permalink:"/docs/java-implementing-workflows"}},c=[],s={rightToc:c};function f(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Workflow encapsulates the orchestration of activities and child workflows.\nIt can also answer synchronous queries and receive external events (also known as signals)."),Object(a.b)("p",null,"A workflow must define an interface class. A workflow interface class must be annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@WorkflowInterface"),".\nAll of its methods must have one of the following annotations:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"@WorkflowMethod")," indicates an entry point to a workflow. It contains parameters such as timeouts and a task list.\nRequired parameters (such as ",Object(a.b)("inlineCode",{parentName:"li"},"executionStartToCloseTimeoutSeconds"),") that are not specified through the annotation must be provided at runtime."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"@SignalMethod")," indicates a method that reacts to external signals. It must have a ",Object(a.b)("inlineCode",{parentName:"li"},"void")," return type."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"@QueryMethod")," indicates a method that reacts to synchronous query requests. It must have a non ",Object(a.b)("inlineCode",{parentName:"li"},"void")," return type.")),Object(a.b)("p",null,"You can have more than one method with the same annotation (except @WorkflowMethod). For example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),'@WorkflowInterface\npublic interface FileProcessingWorkflow {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name="history")\n    List<String> getHistory();\n\n    @QueryMethod(name="status")\n    String getStatus();\n\n    @SignalMethod\n    void retryNow();\n    \n    @SignalMethod\n    void abandon();\n}\n')),Object(a.b)("p",null,"Note that name parameter of workflow method annotations can be used to specify name of workflow, signal and query types.\nIf name is not specified the short name of the workflow interface separated by underscore with the method name is used.\nIn the above code the @WorkflowMethod.name is not specified, thus the workflow type defaults to ",Object(a.b)("inlineCode",{parentName:"p"},'"FileProcessingWorkflow_processFile"'),"."),Object(a.b)("p",null,"We recommended that you use a single value type argument for all types of workflow methods.\nThis way, adding new arguments as fields to the value type is a backwards-compatible change."),Object(a.b)("h1",{id:"workflow-interface-inheritance"},"Workflow Interface Inheritance"),Object(a.b)("p",null,"Workflow interfaces can form inheritance hierarchies. It may be useful for creating components reusable across multiple\nworkflow types. For example imaging a UI or CLI button that allows to call ",Object(a.b)("inlineCode",{parentName:"p"},"retryNow")," signal on any workflow. To implement\nthis feature you can redesign the above interface to:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),'@WorkflowInterface\npublic interface Retryable {\n    @SignalMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface FileProcessingWorkflow extends Retryable {\n\n    @WorkflowMethod\n    String processFile(Arguments args);\n\n    @QueryMethod(name="history")\n    List<String> getHistory();\n\n    @QueryMethod(name="status")\n    String getStatus();\n   \n    @SignalMethod\n    void abandon();\n}\n')),Object(a.b)("p",null,"Then some other workflow can implement it as well:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"@WorkflowInterface\npublic interface MediaProcessingWorkflow extends Retryable {\n    @WorkflowMethod\n    String processBlob(Arguments args);\n}\n")),Object(a.b)("p",null,"Then it would be possible to send signal to both of them using the Retryable interface only:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"Retryable r = client.newWorkflowStab(Retryable.class, workflowId);\nr.retryNow();\n")),Object(a.b)("p",null,"The same technique can be used to query workflows through a base interface."),Object(a.b)("p",null,"Note that an attempt to start workflow through a base interface annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@WorkflowInterface")," is not going to work.\nLet's look at the following ",Object(a.b)("strong",{parentName:"p"},"invalid")," example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"// INVALID CODE!\n@WorkflowInterface\npublic interface BaseWorkflow {\n    @WorkflowMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface Workflow1 extends BaseWorkflow {}\n\n@WorkflowInterface\npublic interface Workflow2 extends BaseWorkflow {}\n")),Object(a.b)("p",null,"An attempt to register implementations of Workflow1 and Workflow2 are going to fail as they are going to use the same\nworkflow type. The type is defined by the type of the class which is annotated with @WorkflowInterface. In this case ",Object(a.b)("inlineCode",{parentName:"p"},"BaseWorkflow"),".\nThe solution is to remove @WorkflowInterface annotation from BaseWorkflow. The following is valid code:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-java"}),"public interface BaseWorkflow {\n    @WorkflowMethod\n    void retryNow();\n}\n\n@WorkflowInterface\npublic interface Workflow1 extends BaseWorkflow {}\n\n@WorkflowInterface\npublic interface Workflow2 extends BaseWorkflow {}\n")),Object(a.b)("p",null,"Implementations of Workflow1 and Workflow2 can registered with the same worker as they will have types defined by their interfaces."))}f.isMDXComponent=!0},183:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var o=n(0),r=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),f=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i({},t,{},e)),n},p=function(e){var t=f(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(o.forwardRef)((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=f(n),b=o,d=p["".concat(l,".").concat(b)]||p[b]||u[b]||a;return n?r.a.createElement(d,i({ref:t},s,{components:n})):r.a.createElement(d,i({ref:t},s))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,l=new Array(a);l[0]=b;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var s=2;s<a;s++)l[s]=n[s];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);