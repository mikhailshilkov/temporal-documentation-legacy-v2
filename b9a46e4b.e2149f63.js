(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{159:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return d}));var i=n(1),o=n(6),a=(n(0),n(183)),l={id:"java-implementing-workflows",title:"Implementing Workflows"},r={id:"java-implementing-workflows",title:"Implementing Workflows",description:"A workflow implementation implements a workflow interface. Each time a new workflow execution is started,",source:"@site/docs/java-implementing-workflows.md",permalink:"/docs/java-implementing-workflows",editUrl:"https://github.com/temporalio/temporal-documentation-legacy-v2/blob/master/docs/java-implementing-workflows.md",sidebar:"docs",previous:{title:"Workflow Interface",permalink:"/docs/java-workflow-interface"},next:{title:"Starting workflow executions",permalink:"/docs/java-starting-workflow-executions"}},s=[{value:"Workflow Implementation Constraints",id:"workflow-implementation-constraints",children:[]},{value:"Calling Activities",id:"calling-activities",children:[]},{value:"Calling Activities Asynchronously",id:"calling-activities-asynchronously",children:[]},{value:"Child Workflows",id:"child-workflows",children:[]}],c={rightToc:s};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"A workflow implementation implements a workflow interface. Each time a new workflow execution is started,\na new instance of the workflow implementation object is created. Then, one of the methods\n(depending on which workflow type has been started) annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@WorkflowMethod")," is invoked. As soon as this method\nreturns, the workflow execution is closed. While workflow execution is open, it can receive calls to signal and query methods.\nNo additional calls to workflow methods are allowed. The workflow object is stateful, so query and signal methods\ncan communicate with the other parts of the workflow through workflow object fields."),Object(a.b)("h2",{id:"workflow-implementation-constraints"},"Workflow Implementation Constraints"),Object(a.b)("p",null,"Temporal uses the ",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing"}),"Microsoft Azure Event Sourcing pattern")," to recover\nthe state of a workflow object including its threads and local variable values.\nIn essence, every time a workflow state has to be restored, its code is re-executed from the beginning. When replaying, side\neffects (such as activity invocations) are ignored because they are already recorded in the workflow event history.\nWhen writing workflow logic, the replay is not visible, so the code should be written since it executes only once.\nThis design puts the following constraints on the workflow implementation:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Do not use any mutable global variables because multiple instances of workflows are executed in parallel."),Object(a.b)("li",{parentName:"ul"},"Do not call any non-deterministic functions like non seeded random or UUID.randomUUID() directly from the workflow code.")),Object(a.b)("p",null,"Always do the following in the workflow implementation code:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Don\u2019t perform any IO or service calls as they are not usually deterministic. Use activities for this."),Object(a.b)("li",{parentName:"ul"},"Only use ",Object(a.b)("inlineCode",{parentName:"li"},"Workflow.currentTimeMillis()")," to get the current time inside a workflow."),Object(a.b)("li",{parentName:"ul"},"Do not use native Java ",Object(a.b)("inlineCode",{parentName:"li"},"Thread")," or any other multi-threaded classes like ",Object(a.b)("inlineCode",{parentName:"li"},"ThreadPoolExecutor"),". Use ",Object(a.b)("inlineCode",{parentName:"li"},"Async.function")," or ",Object(a.b)("inlineCode",{parentName:"li"},"Async.procedure"),"\nto execute code asynchronously."),Object(a.b)("li",{parentName:"ul"},"Don't use any synchronization, locks, and other standard Java blocking concurrency-related classes besides those provided\nby the Workflow class. There is no need in explicit synchronization because multi-threaded code inside a workflow is\nexecuted one thread at a time and under a global lock.",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Call ",Object(a.b)("inlineCode",{parentName:"li"},"WorkflowThread.sleep")," instead of ",Object(a.b)("inlineCode",{parentName:"li"},"Thread.sleep"),"."),Object(a.b)("li",{parentName:"ul"},"Use ",Object(a.b)("inlineCode",{parentName:"li"},"Promise")," and ",Object(a.b)("inlineCode",{parentName:"li"},"CompletablePromise")," instead of ",Object(a.b)("inlineCode",{parentName:"li"},"Future")," and ",Object(a.b)("inlineCode",{parentName:"li"},"CompletableFuture"),"."),Object(a.b)("li",{parentName:"ul"},"Use ",Object(a.b)("inlineCode",{parentName:"li"},"WorkflowQueue")," instead of ",Object(a.b)("inlineCode",{parentName:"li"},"BlockingQueue"),"."))),Object(a.b)("li",{parentName:"ul"},"Use ",Object(a.b)("inlineCode",{parentName:"li"},"Workflow.getVersion")," when making any changes to the workflow code. Without this, any deployment of updated workflow code\nmight break already open workflows.  "),Object(a.b)("li",{parentName:"ul"},"Don\u2019t access configuration APIs directly from a workflow because changes in the configuration might affect a workflow execution path.\nPass it as an argument to a workflow function or use an activity to load it.")),Object(a.b)("p",null,"Workflow method arguments and return values are serializable to a byte array using the provided\n",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"https://static.javadoc.io/com.uber.cadence/cadence-client/2.4.1/index.html?com/uber/cadence/converter/DataConverter.html"}),"DataConverter"),"\ninterface. The default implementation uses JSON serializer, but you can use any alternative serialization mechanism."),Object(a.b)("p",null,"The values passed to workflows through invocation parameters or returned through a result value are recorded in the execution history.\nThe entire execution history is transferred from the Temporal service to workflow workers with every event that the workflow logic needs to process.\nA large execution history can thus adversely impact the performance of your workflow.\nTherefore, be mindful of the amount of data that you transfer via activity invocation parameters or return values.\nOtherwise, no additional limitations exist on activity implementations."),Object(a.b)("h2",{id:"calling-activities"},"Calling Activities"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Workflow.newActivityStub")," returns a client-side stub that implements an activity interface.\nIt takes activity type and activity options as arguments. Activity options are needed only if some of the required\ntimeouts are not specified through the ",Object(a.b)("inlineCode",{parentName:"p"},"@ActivityMethod")," annotation."),Object(a.b)("p",null,"Calling a method on this interface invokes an activity that implements this method.\nAn activity invocation synchronously blocks until the activity completes, fails, or times out. Even if activity\nexecution takes a few months, the workflow code still sees it as a single synchronous invocation.\nIt doesn't matter what happens to the processes that host the workflow. The business logic code\njust sees a single method call."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"public class FileProcessingWorkflowImpl implements FileProcessingWorkflow {\n\n    private final FileProcessingActivities activities;\n\n    public FileProcessingWorkflowImpl() {\n        this.activities = Workflow.newActivityStub(\n                FileProcessingActivities.class,\n                ActivityOptions.newBuilder()\n                        .setStartToCloseTimeout(Duration.ofHours(1))\n                        .build());\n    }\n\n    @Override\n    public void processFile(Arguments args) {\n        String localName = null;\n        String processedName = null;\n        try {\n            localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());\n            processedName = activities.processFile(localName);\n            activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);\n        } finally {\n            if (localName != null) { // File was downloaded.\n                activities.deleteLocalFile(localName);\n            }\n            if (processedName != null) { // File was processed.\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n    ...\n}\n")),Object(a.b)("p",null,"If different activities need different options, like timeouts or a task list, multiple client-side stubs can be created\nwith different options."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'public FileProcessingWorkflowImpl() {\n    ActivityOptions options1 = ActivityOptions.newBuilder()\n             .setTaskList("taskList1")\n             .setStartToCloseTimeout(Duration.ofMinutes(10))\n             .build();\n    this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);\n\n    ActivityOptions options2 = ActivityOptions.newBuilder()\n             .setTaskList("taskList2")\n             .setStartToCloseTimeout(Duration.ofMinutes(5))\n             .build();\n    this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);\n}\n')),Object(a.b)("h2",{id:"calling-activities-asynchronously"},"Calling Activities Asynchronously"),Object(a.b)("p",null,"Sometimes workflows need to perform certain operations in parallel.\nThe ",Object(a.b)("inlineCode",{parentName:"p"},"Async")," class static methods allow you to invoke any activity asynchronously. The calls return a ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," result immediately.\n",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," is similar to both Java ",Object(a.b)("inlineCode",{parentName:"p"},"Future")," and ",Object(a.b)("inlineCode",{parentName:"p"},"CompletionStage"),". The ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," ",Object(a.b)("inlineCode",{parentName:"p"},"get")," blocks until a result is available.\nIt also exposes the ",Object(a.b)("inlineCode",{parentName:"p"},"thenApply")," and ",Object(a.b)("inlineCode",{parentName:"p"},"handle")," methods. See the ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," JavaDoc for technical details about differences with ",Object(a.b)("inlineCode",{parentName:"p"},"Future"),"."),Object(a.b)("p",null,"To convert a synchronous call:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"String localName = activities.download(sourceBucket, sourceFile);\n")),Object(a.b)("p",null,"To asynchronous style, the method reference is passed to ",Object(a.b)("inlineCode",{parentName:"p"},"Async.function")," or ",Object(a.b)("inlineCode",{parentName:"p"},"Async.procedure"),"\nfollowed by activity arguments:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"Promise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);\n")),Object(a.b)("p",null,"Then to wait synchronously for the result:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"String localName = localNamePromise.get();\n")),Object(a.b)("p",null,"Here is the above example rewritten to call download and upload in parallel on multiple files:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),"public void processFile(Arguments args) {\n    List<Promise<String>> localNamePromises = new ArrayList<>();\n    List<String> processedNames = null;\n    try {\n        // Download all files in parallel.\n        for (String sourceFilename : args.getSourceFilenames()) {\n            Promise<String> localName = Async.function(activities::download,\n                args.getSourceBucketName(), sourceFilename);\n            localNamePromises.add(localName);\n        }\n        // allOf converts a list of promises to a single promise that contains a list\n        // of each promise value.\n        Promise<List<String>> localNamesPromise = Promise.allOf(localNamePromises);\n\n        // All code until the next line wasn't blocking.\n        // The promise get is a blocking call.\n        List<String> localNames = localNamesPromise.get();\n        processedNames = activities.processFiles(localNames);\n\n        // Upload all results in parallel.\n        List<Promise<Void>> uploadedList = new ArrayList<>();\n        for (String processedName : processedNames) {\n            Promise<Void> uploaded = Async.procedure(activities::upload,\n                args.getTargetBucketName(), args.getTargetFilename(), processedName);\n            uploadedList.add(uploaded);\n        }\n        // Wait for all uploads to complete.\n        Promise<?> allUploaded = Promise.allOf(uploadedList);\n        allUploaded.get(); // blocks until all promises are ready.\n    } finally {\n        for (Promise<String> localNamePromise : localNamePromises) {\n            // Skip files that haven't completed downloading.\n            if (localNamePromise.isCompleted()) {\n                activities.deleteLocalFile(localNamePromise.get());\n            }\n        }\n        if (processedNames != null) {\n            for (String processedName : processedNames) {\n                activities.deleteLocalFile(processedName);\n            }\n        }\n    }\n}\n")),Object(a.b)("h2",{id:"child-workflows"},"Child Workflows"),Object(a.b)("p",null,"Besides activities, a workflow can also orchestrate other workflows."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Workflow.newChildWorkflowStub")," returns a client-side stub that implements a child workflow interface.\nIt takes a child workflow type and optional child workflow options as arguments. Workflow options may be needed to override\nthe timeouts and task list if they differ from the ones defined in the ",Object(a.b)("inlineCode",{parentName:"p"},"@WorkflowMethod")," annotation or parent workflow."),Object(a.b)("p",null," The first call to the child workflow stub must always be to a method annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@WorkflowMethod"),". Similar to activities, a call\ncan be made synchronous or asynchronous by using ",Object(a.b)("inlineCode",{parentName:"p"},"Async#function")," or ",Object(a.b)("inlineCode",{parentName:"p"},"Async#procedure"),". The synchronous call blocks until a child workflow completes. The asynchronous call\nreturns a ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," that can be used to wait for the completion. After an async call returns the stub, it can be used to send signals to the child\nby calling methods annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@SignalMethod"),". Querying a child workflow by calling methods annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@QueryMethod"),"\nfrom within workflow code is not supported. However, queries can be done from activities\nusing the provided ",Object(a.b)("inlineCode",{parentName:"p"},"WorkflowClient")," stub."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'@WorkflowInterface\npublic interface GreetingChild {\n   @WorkflowMethod\n   String composeGreeting(String greeting, String name);\n}\n\npublic static class GreetingWorkflowImpl implements GreetingWorkflow {\n\n   @Override\n   public String getGreeting(String name) {\n       GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n\n       // This is a blocking call that returns only after child has completed.\n       return child.composeGreeting("Hello", name );\n   }\n}\n')),Object(a.b)("p",null,"Running two children in parallel:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'public static class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n\n        // Workflows are stateful, so a new stub must be created for each new child.\n        GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting1 = Async.function(child1::composeGreeting, "Hello", name);\n\n        // Both children will run concurrently.\n        GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting2 = Async.function(child2::composeGreeting, "Bye", name);\n\n        // Do something else here.\n        ...\n        return "First: " + greeting1.get() + ", second: " + greeting2.get();\n    }\n}\n')),Object(a.b)("p",null,"To send a signal to a child, call a method annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@SignalMethod"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-java"}),'@WorkflowInterface\npublic interface GreetingChild {\n    @WorkflowMethod\n    String composeGreeting(String greeting, String name);\n\n    @SignalMethod\n    void updateName(String name);\n}\n\npublic static class GreetingWorkflowImpl implements GreetingWorkflow {\n\n    @Override\n    public String getGreeting(String name) {\n        GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);\n        Promise<String> greeting = Async.function(child::composeGreeting, "Hello", name);\n        child.updateName("Temporal");\n        return greeting.get();\n    }\n}\n')),Object(a.b)("p",null,"Calling methods annotated with ",Object(a.b)("inlineCode",{parentName:"p"},"@QueryMethod")," is not allowed from within workflow code. Use an activity to call them."))}d.isMDXComponent=!0},183:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return b}));var i=n(0),o=n.n(i);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),d=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r({},t,{},e)),n},m=function(e){var t=d(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=Object(i.forwardRef)((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=d(n),p=i,b=m["".concat(l,".").concat(p)]||m[p]||u[p]||a;return n?o.a.createElement(b,r({ref:t},c,{components:n})):o.a.createElement(b,r({ref:t},c))}));function b(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,l=new Array(a);l[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var c=2;c<a;c++)l[c]=n[c];return o.a.createElement.apply(null,l)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);